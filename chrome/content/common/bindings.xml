<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is DownThemAll
 *
 * The Initial Developer of the Original Code is Nils Maier
 * Portions created by the Initial Developer are Copyright (C) 2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Nils Maier <MaierMan@web.de>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** -->
<!DOCTYPE bindings [
	<!ENTITY % globalDTD SYSTEM "chrome://global/locale/global.dtd">
	%globalDTD;
]>

<bindings xmlns="http://www.mozilla.org/xbl" xmlns:xbl="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	<!-- closebox -->
	<binding id="closebox"
		extends="chrome://global/content/bindings/groupbox.xml#groupbox">
		<content>
			<xul:hbox class="groupbox-title" align="center" pack="start">
				<children includes="caption" />
			</xul:hbox>
			<xul:box flex="1" class="childrenbox" xbl:inherits="orient,align,pack,collapsed=closed">
				<children />
			</xul:box>
		</content>
		<implementation implements="nsIAccessibleProvider">
			<property name="closed">
				<getter>
					return this.getAttribute('closed') == 'true';
				</getter>
				<setter>
					this.setAttribute('closed', val ? 'true' : 'false');
				</setter>
			</property>
			<property name="shouldResize">
				<getter>
					return this.getAttribute('shouldResize') == 'true';
				</getter>
				<setter>
					this.setAttribute('shouldResize', val ? 'true' : 'false');
				</setter>
			</property>
			<property name="accessibleType" readonly="true">
				<getter>
          <![CDATA[
            return Components.interfaces.nsIAccessibleProvider.XULGroupbox;
          ]]>
				</getter>
			</property>
		</implementation>
	</binding>
	<binding id="closebox-caption"
		extends="chrome://global/content/bindings/groupbox.xml#caption">
		<handlers>
			<handler event="click">
				this.parentNode.closed =
				!this.parentNode.closed; if (this.parentNode.shouldResize) {
				window.sizeToContent(); }
			</handler>
		</handlers>
	</binding>

	<binding id="saveddropdown">
		<content>
			<xul:menulist anonid="list" editable="true"
				xbl:inherits="crop,readonly,disabled,flex,tooltiptext,oninput=onchange,onselect=onchange,error">
				<xul:menupopup anonid="popup"
					xbl:inherits="crop,onselect=onchange,oncommand=onchange" />
			</xul:menulist>
		</content>
		<implementation>
			<constructor><![CDATA[
				try {
					this._load();
				}
				catch (ex) {
					DTA.Debug.log("Loading of saveddropdown failed:", ex);
				}
			]]></constructor>
			<field name="modified">false</field>
			<property name="_list"
				onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'list');" />
			<property name="_popup"
				onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'popup');" />
			<property name="_pref" onget="return this.getAttribute('preference')" />
			<property name="_values">
				<getter><![CDATA[
					var rv = this.getAttribute('default');
					if (rv.length == 0) {
						rv = '[]';
					}
					if (rv[0] != '[') {
						rv = '[\'' + rv + '\']';
					}
					try {
						return eval(DTA.Preferences.getExt(this._pref, rv));
					}
					catch (ex) {
						DTA.Debug.log("Cannot initialize from preferences:", ex);
						return eval(rv);
					}
				]]></getter>
			</property>
			<property name="_max"
				onget="return DTA.Preferences.getExt('history', 5);" />
			<property name="inputField" onget="return this._list.inputField" />
			<property name="value" onget="return this._list.label">
				<setter>
					val = String(val);
					if (this.value == val) {
					return;
					}
					this._list.label = val;
					this._modified = true;
				</setter>
			</property>
			<method name="_load">
				<body><![CDATA[
					var values = this._values;
					var popup = this._popup;
					
					while (popup.hasChildNodes()) {
						popup.removeChild(popup.lastChild);
					}

					for each (var val in values) {
						var node = document.createElement('menuitem');
						node.setAttribute('label', val);
						if (this.hasAttribute('crop')) {
							node.setAttribute('crop', this.getAttribute('crop'));
						}
						popup.appendChild(node);
					}

					if (values.length) {
						this._list.selectedIndex = 0;
						this.value = values[0];
					}				
					if (this.hasAttribute('readonly')) {
						this._list.removeAttribute('editable');
					}
					this._modified = false;
				]]></body>
			</method>
			<method name="reload">
				<body>this._load();</body>
			</method>
			<method name="save">
				<body><![CDATA[
					var n = this.value;
					if ((!this.modified && this._list.selectedIndex == 0) || (n.length == 0 && !this.hasAttribute('allowempty'))) {
						return;
					}
					var inValues = this._values;
					var max = this._max;
					var outValues = [n];
					for (var i = 0; i < inValues.length && i < max - 1 && outValues.length < max; ++i) {
						if (n != inValues[i] && inValues[i].length) {
							outValues.push(inValues[i]);
						}
					}
					try {
						DTA.Preferences.setExt(this._pref, outValues.toSource());
					}
					catch (ex) {
						DTA.Debug.log("Cannot save saveddropdown", ex);
					} 
				]]></body>
			</method>
			<method name="clear">
				<body>
					DTA.Preferences.resetExt(this._pref);
				</body>
			</method>
		</implementation>
	</binding>

	<binding id="metalinker-item"
		extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
		<content>
			<xul:vbox flex="1">
				<xul:hbox class="metalink-mainbox" flex="1">
					<xul:image class="metalinker-icon" xbl:inherits="src=iconURL" />
					<xul:vbox class="metalink-infobox" flex="1">
						<xul:checkbox anonid="check" xbl:inherits="label=identity,checked" />
						<xul:hbox flex="1" anonid="additionallinks" />
						<xul:hbox>
							<xul:description flex="1" crop="center"
								xbl:inherits="value=url" />
						</xul:hbox>
					</xul:vbox>
					<xul:vbox class="metalinker-additional" anonid="additional" />
				</xul:hbox>
				<xul:description class="metalinker-description"
					flex="1" anonid="desc" />
			</xul:vbox>
		</content>

		<implementation>
			<constructor><![CDATA[
				var dl = this.download;
				this.setAttribute('checked', dl.selected);
				var id = '';
				if (dl.identity) {
					id = dl.identity + ' (' + dl.fileName + ')';
				}
				else {
					id = dl.fileName;
				}
				this.setAttribute('identity', id);
				this.setAttribute('iconURL', dl.logo ? dl.logo : getIcon(dl.url.usable, false, 32));
				this.setAttribute('url', dl.url.usable);
				
				function addSimple(e) {
					if (dl[e]) {
						var n = document.createElement('description');
						n.appendChild(document.createTextNode(_(e, [dl[e]])));
						n.setAttribute('crop', 'end');
						this._additional.appendChild(n);
					}
				};
				function addLink(e) {
					if (dl[e]) {
						var n = document.createElement('description');
						n.setAttribute('class', 'text-link');
						n.setAttribute('onclick', 'Metalinker.openLink(this)');
						n.setAttribute('crop', 'center');
						n.setAttribute('flex', '1');
						n.link = dl[e][1];							
						n.appendChild(document.createTextNode(dl[e][0]));
						this._additionalLinks.appendChild(n);
					}
				};
				['size', 'version', 'sys', 'lang', 'copyright', 'mirrors'].forEach(addSimple, this);
				['publisher', 'license'].forEach(addLink, this);
				
				if (dl.description) {
					this._desc.appendChild(document.createTextNode(dl.description));
				}
			]]></constructor>
			<field name="_checkbox">document.getAnonymousElementByAttribute(this,
				'anonid', 'check');</field>
			<field name="_additional">document.getAnonymousElementByAttribute(this,
				'anonid', 'additional');</field>
			<field name="_additionalLinks">document.getAnonymousElementByAttribute(this,
				'anonid', 'additionallinks');</field>
			<field name="_desc">document.getAnonymousElementByAttribute(this,
				'anonid', 'desc');</field>
			<property name="checked" onget="return this._checkbox.checked;"
				onset="this._checkbox.checked = !!val; return !!val;" />
		</implementation>
	</binding>

	<binding id="hashinput">
		<content>
			<xul:hbox flex="1">
				<xul:menulist anonid="type" readonly="true"
					xbl:inherits="disabled,error">
					<xul:menupopup anonid="types" />
				</xul:menulist>
				<xul:textbox anonid="hash" flex="1" xbl:inherits="readonly,disabled"
					type="autocomplete" />
			</xul:hbox>
		</content>
		<implementation>
			<constructor><![CDATA[
				this._typemap = {};
				for (x in DTA.SUPPORTED_HASHES) {
					var e = document.createElement('menuitem');
					e.setAttribute('value', x);
					e.setAttribute('label', x);
					this._types.appendChild(e);
					this._typemap[x] = e;
				}			
			]]></constructor>
			<property name="_type"
				onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'type');" />
			<property name="_types"
				onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'types');" />
			<property name="_hash"
				onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'hash');" />
			<property name="checked" onget="return this._checkbox.checked;" />
			<property name="inputField" onget="return this._hash.inputField;" />
			<property name="isValid">
				<getter><![CDATA[
					try {
						if (this._hash.value.length) {
							new DTA.Hash(this._hash.value, this._type.value);
						}
						return true;
					}
					catch(ex) {
						return false;
					}
				]]></getter>
			</property>
			<property name="value">
				<getter><![CDATA[
					if (this._hash.value.length) {
						return new DTA.Hash(this._hash.value, this._type.value);
					}
					return null;
				]]></getter>
				<setter><![CDATA[
					if (val) {
						this._hash.value = val.sum;
						this._type.selectedItem = this._typemap[val.type];
					}
					else {
						this._hash.value = '';
					}
					return val;
				]]></setter>
			</property>
		</implementation>
	</binding>

	<binding id="menu-iconic-addressable"
		extends="chrome://global/content/bindings/menu.xml#menu-base">
		<content>
			<xul:hbox class="menu-iconic-left" align="center" pack="center">
				<xul:image class="menu-iconic-icon" xbl:inherits="src=image" />
			</xul:hbox>
			<xul:label class="menu-iconic-text" flex="1"
				xbl:inherits="value=label,accesskey,crop" crop="right" />
			<xul:hbox class="menu-accel-container" anonid="accel">
				<xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext" />
			</xul:hbox>
			<xul:hbox class="menu-right" chromedir="&locale.dir;"
				xbl:inherits="_moz-menuactive,disabled" align="center" pack="center">
				<xul:image />
			</xul:hbox>
			<children includes="menupopup|template" />
		</content>
	</binding>

	<binding id="speed-limit-list-popup"
		extends="chrome://global/content/bindings/popup.xml#popup-scrollbars">
		<implementation>
			<constructor><![CDATA[
				this.limit = -1;
				this.fill();
			]]></constructor>
			<property name="hint">
				<getter>
					return this._hint || 0;
				</getter>
				<setter>
					if (!isFinite(val)) {
						throw new Error("Provide a valid number");
					}
					if (this._hint != val) { 
						this._hint = val;
					}
				</setter>
			</property>
			<property name="limit">
				<getter>
					return parseInt(this.parentNode.value) || -1;
				</getter>
				<setter><![CDATA[
					if (!isFinite(val)) {
						throw new Error("Provide a valid number");
					}
					if (this.parentNode.value != val) {
						this.parentNode.value = val;
						this.fill();
					}
				]]></setter>
			</property>
			<property name="selectedItem">
				<setter><![CDATA[
					let pn = this.parentNode;
					if (pn.localName == 'menulist') {
						pn.selectedItem = val;
					}
					else {
						val.setAttribute('checked', 'true');
					}
				]]></setter>
			</property>
			<method name="appendItem">
				<parameter name="label"/>
				<parameter name="value"/>
				<parameter name="description"/>
				<body><![CDATA[
					let item = document.createElement('menuitem');
        	item.setAttribute("label", label);
          item.setAttribute("value", value);
          if (description) {
            item.setAttribute("description", description);
          }
          this.appendChild(item);
          return item;
				]]></body>
			</method>
			<method name="fill">
				<body><![CDATA[
					function scale(e) e >= 1000 ? Math.round(e / 50) * 50 : (e >= 400 ? Math.round(e / 5) * 5 : e);

					while (this.firstChild) {
						this.removeChild(this.firstChild);
					}
					
					let iv = Math.max(this.limit, -1);
					let m = Math.round((iv > 0 ? iv : this.hint / 2) / 1024);
					m = scale(iv > 1 ? m : 150);
					let vals = [0,1,2,5,10,20,50];
					if (m >= 1000) {
						vals = [0,100,200,500,1000];
					}
					else if (m > 400) {
						vals = [0,50,100,200,500];
					}
					
					let items = [10, 50, 100, 250, 1000]; // always include these
					for each (let v in vals) {
						if (v && m - v > 1) {
							items.push(m - v);
						}
						items.push(m + v);
					}
					items = items
						.map(scale)
						.filter(function(e) !((e in this) || (this[e] = null)), {}) // makes array unique
						.sort(function(a, b) a - b);
					let sep = document.createElement('menuseparator');
					for each (let v in items.map(function(e) e * 1024)) {
						let item = this.appendItem(Utils.formatKBytes(v, 0) + '/s', v);
						if (v == iv) {
							if (item.previousSibling) { 
								this.insertBefore(sep.cloneNode(false), item);
							}
							this.selectedItem = item;
							this.appendChild(sep.cloneNode(false));
						}
					}
					this.appendChild(sep);
					let item = this.appendItem(_('unlimitedspeed'), -1);
					if (iv == -1) {
						this.selectedItem = item;
					}
					return true;
				]]></body>
			</method>
		</implementation>
		<handlers>
			<handler phase="capturing" event="popupshowing"><![CDATA[
				this.fill();
			]]></handler>
			<handler phase="capturing" event="command"><![CDATA[
				this.parentNode.blur();
				let nv = parseInt(event.originalTarget.value);
				if (nv != this.limit) {
					this.limit = nv;
				}
			]]></handler>
		</handlers>
	</binding>

</bindings>
				
		